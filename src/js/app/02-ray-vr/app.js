"use strict";window.THREE = require('three');window.THREE.isDebug = false;const WEBVR = require('../../vendors/three/WebVR');require('../../vendors/three/effects/VREffect');require('../../vendors/three/controls/VRControls');var ViveController = require('../../vendors/three/custom-three-vive-controller/index')(THREE, './');const glslify = require('glslify');const raf = require('raf');var clock = new THREE.Clock();var scene, camera, room, controls, container, renderer, controller1, controller2, effect;var line, line2, deMesh;var worldScaled = 1 / 100;var cubeArr = [];var originVertice = new THREE.Vector3(0, 0, 0);var originDirection = new THREE.Vector3(0, 0.00, -5 * worldScaled);var lineGeo;var yelMat = new THREE.MeshBasicMaterial({color: 0xffff00});var blueMat = new THREE.MeshBasicMaterial({color: 0xffffff});var greenMat = new THREE.MeshBasicMaterial({color: 0x00ff00});var raycaster = new THREE.Raycaster();require('domready')(() => {    init();    loop()});function init() {    container = document.createElement( 'div' );    document.body.appendChild( container );    scene = new THREE.Scene();    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );    scene.add( camera );    room = new THREE.Mesh(        new THREE.BoxGeometry( 6, 6, 6, 8, 8, 8 ),        new THREE.MeshBasicMaterial( { color: 0x404040, wireframe: true } )    );    scene.add( room );    scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );    renderer = new THREE.WebGLRenderer({antialias: true});    renderer.setClearColor( 0x505050 );    renderer.setPixelRatio( window.devicePixelRatio );    renderer.setSize( window.innerWidth, window.innerHeight );    renderer.sortObjects = false;    container.appendChild( renderer.domElement );    controls = new THREE.VRControls( camera );    controls.standing = true;    controller1 = new ViveController(0, controls);    scene.add(controller1);    if(THREE.isDebug){        var axisHelper = new THREE.AxisHelper( 0.1 );        controller1.add(axisHelper)    }    var light = new THREE.DirectionalLight( 0xffffff );    light.position.set( 1, 1, 1 ).normalize();    scene.add( light );    var geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);    for(var ii = 0; ii < 80; ii++){        var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );        object.position.x = (Math.random() * 4 - 2)/3;        object.position.y = (Math.random() * 4 - 2)/3;        object.position.z = (Math.random() * 4 - 2)/3;        object.rotation.x = Math.random() * 2 * Math.PI;        object.rotation.y = Math.random() * 2 * Math.PI;        object.rotation.z = Math.random() * 2 * Math.PI;        var randomScale = 1 + Math.random();        object.scale.set(randomScale, randomScale, randomScale);        scene.add(object);        cubeArr.push(object);    }    controller2 = new ViveController(1, controls);    scene.add(controller2);    effect = new THREE.VREffect(renderer);    var deMeshGeo = new THREE.BoxGeometry(6 * worldScaled, 6 * worldScaled, 6 * worldScaled);    deMesh = new THREE.Mesh(deMeshGeo, new THREE.MeshBasicMaterial({color : 0xffffff}));    // scene.add(deMesh);    lineGeo = new THREE.Geometry();    lineGeo.vertices.push(new THREE.Vector3(0, 0, 0));    lineGeo.vertices.push(new THREE.Vector3(0, 0.00, -5 * worldScaled));    line = new THREE.Line(lineGeo, new THREE.MeshBasicMaterial({color: 0x0000ff, side : THREE.DoubleSide}));    scene.add(line);    var lineGeo2 = new THREE.Geometry();    line2 = new THREE.Line(lineGeo2);    scene.add(line2);    if (WEBVR.isAvailable() === true) {        document.body.appendChild(WEBVR.getButton(effect));    }    window.addEventListener('resize', onWindowResize, false);}function onWindowResize() {    camera.aspect = window.innerWidth / window.innerHeight;    camera.updateProjectionMatrix();    effect.setSize(window.innerWidth, window.innerHeight);}function loop() {    raf(loop);    controls.update();    updateController(controller1, line);    updateController(controller2, line2)    effect.render(scene, camera);}function updateController(_controller, _line) {    var transformedOriginVertice = new THREE.Vector3().copy(originVertice).applyMatrix4(_controller.matrix);    var direction = new THREE.Vector3().copy(originDirection).applyMatrix4(_controller.matrix);    _line.geometry.vertices[0] = transformedOriginVertice;    var directionNormalizedVec = new THREE.Vector3().copy(direction).sub(transformedOriginVertice).normalize();    raycaster.set(transformedOriginVertice, directionNormalizedVec);    var intersects = raycaster.intersectObjects(cubeArr, false);    if(intersects.length > 0){        var intersectObj = intersects[0];        var intersectMesh = intersectObj.object;        var curQuaternion = intersectMesh.quaternion;        var rotateAngle = 1/50;        var rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(directionNormalizedVec, rotateAngle);        curQuaternion = curQuaternion.multiplyQuaternions(curQuaternion, rotationQuaternion);        curQuaternion.normalize();        intersectMesh.setRotationFromQuaternion(curQuaternion);        _line.geometry.vertices[1] = intersectObj.point;        _line.material = yelMat;    }else{        _line.material = blueMat;        _line.geometry.vertices[1] = direction;    }    _line.geometry.verticesNeedUpdate = true;    _line.frustumCulled = false;}